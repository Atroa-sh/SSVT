module Exercise1 where

import Test.QuickCheck

{-
 Types of outputs which are not yet covered by mutations in mutation.hs:
    There are no empty lists generated by the mutators. Only anyList is able to generate empty lists,
    but the chance that it will do so, is very small.

Weaknesses and strengths of the mutators:
    addElements:
        strength: The mutator is able to generate a wide variety of possible mutants.
        weakness: A section of the original list will always be subset of the resulting mutant.
        Not covered: Empty lists, inserting elements inbetween elements of the list

    removeElements:
        strenght: The mutator is able to generate shorter lists consistently.
        weakness: The elements that are removed

 1. Shuffle the order of the list
    The order of the list could have some influence on the output of a function
 2. Add elements to random positions in the list
 3. Remove all elements from the list (empty list)
 4. Remove elements from the start of the list
 5. Remove elements from the middle of the list
 6. Remove elements from a random positions in the list
 7. Perform arithmic operations on any or all elements in the list (add, sub, mul, div, mod, neg, reverse, etc.)
    I think theses ones speaks for themselves. Changing the amount of elements and content of a list,
    should affect the behaviour of functions where the list is used.
-}

-- 3:
removeAllElements :: [Integer] -> Gen [Integer]
removeAllElements xs = return []

-- 4:
removeElementsFromStart :: [Integer] -> Gen [Integer]
removeElementsFromStart xs = choose (1, length xs - 1) >>= \x -> return $ drop x xs

-- 5:
removeElementsFromMiddle :: [Integer] -> Gen [Integer]
removeElementsFromMiddle xs = choose (1, length xs - 1) >>= \x -> return $ take x xs ++ drop (x + 1) xs

-- 6:
removeElementsFromRandomPosition :: [Integer] -> Gen [Integer]
removeElementsFromRandomPosition xs = choose (1, length xs - 1) >>= \x -> return $ take (x - 1) xs ++ drop x xs

-- 7:
performArithmicOperations :: [Integer] -> Gen [Integer]
performArithmicOperations xs = return $ map negate xs
